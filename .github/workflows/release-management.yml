name: Release Management

on:
  push:
    tags:
      - 'v*'
  release:
    types: [ published ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release'
        required: true
        type: string
      release_type:
        description: 'Type of release'
        required: true
        default: 'minor'
        type: choice
        options:
        - major
        - minor
        - patch
        - prerelease

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Checkout code
      if: ${{ steps.check-release-secrets.outputs.ready == 'true' }}
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Generate version number
      id: version
      run: |
        if [ "${{ github.event.inputs.release_type }}" = "major" ]; then
          VERSION=$(echo "${{ github.event.inputs.version }}" | sed 's/^v//' | awk -F. '{print $1+1".0.0"}')
        elif [ "${{ github.event.inputs.release_type }}" = "minor" ]; then
          VERSION=$(echo "${{ github.event.inputs.version }}" | sed 's/^v//' | awk -F. '{print $1"."$2+1".0"}')
        elif [ "${{ github.event.inputs.release_type }}" = "patch" ]; then
          VERSION=$(echo "${{ github.event.inputs.version }}" | sed 's/^v//' | awk -F. '{print $1"."$2"."$3+1}')
        else
          VERSION="${{ github.event.inputs.version }}"
        fi
        echo "version=v$VERSION" >> $GITHUB_OUTPUT
        echo "VERSION=$VERSION" >> $GITHUB_ENV

    - name: Create release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.version.outputs.version }}
        release_name: Release ${{ steps.version.outputs.version }}
        body: |
          ## Release ${{ steps.version.outputs.version }}
          
          ### Changes
          - Automated release generated by CI/CD pipeline
          - Docker images built and pushed to registry
          - Production deployment ready
          
          ### Docker Images
          - `${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}`
          - `${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}-websocket`
          
          ### Deployment
          This release is ready for production deployment.
        draft: false
        prerelease: ${{ github.event.inputs.release_type == 'prerelease' }}

  build-release:
    name: Build Release Images
    runs-on: ubuntu-latest
    needs: create-release
    if: always() && (needs.create-release.result == 'success' || github.event_name == 'release')
    
    steps:
    - name: Checkout code
      if: ${{ steps.check-rollback-secrets.outputs.ready == 'true' }}
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push main application image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.prod
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push WebSocket image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.websocket
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-websocket:${{ steps.meta.outputs.version }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  generate-changelog:
    name: Generate Changelog
    runs-on: ubuntu-latest
    needs: create-release
    if: always() && (needs.create-release.result == 'success' || github.event_name == 'release')
    
    steps:
    - name: Checkout code
      if: ${{ steps.check-cleanup-secrets.outputs.ready == 'true' }}
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Generate changelog
      id: changelog
      run: |
        # Get the previous tag
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
        
        # Generate changelog
        if [ -n "$PREVIOUS_TAG" ]; then
          CHANGELOG=$(git log --pretty=format:"- %s (%h)" $PREVIOUS_TAG..HEAD)
        else
          CHANGELOG=$(git log --pretty=format:"- %s (%h)" --max-count=20)
        fi
        
        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGELOG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Update release with changelog
      uses: actions/github-script@v6
      with:
        script: |
          const { data: release } = await github.rest.repos.getReleaseByTag({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag: context.ref.replace('refs/tags/', '')
          });
          
          const changelog = `${{ steps.changelog.outputs.changelog }}`;
          
          await github.rest.repos.updateRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            release_id: release.id,
            body: release.body + `\n\n### Changelog\n${changelog}`
          });

  security-scan-release:
    name: Security Scan Release
    runs-on: ubuntu-latest
    needs: build-release
    if: always() && needs.build-release.result == 'success'
    
    steps:
    - name: Checkout code
      if: ${{ steps.check-release-secrets.outputs.ready == 'true' }}
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build Docker image for scanning
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.prod
        push: false
        tags: zenamanage:release-scan
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: 'zenamanage:release-scan'
        format: 'sarif'
        output: 'trivy-release-results.sarif'

    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-release-results.sarif'

    - name: Run Trivy vulnerability scanner (JSON)
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: 'zenamanage:release-scan'
        format: 'json'
        output: 'trivy-release-results.json'

    - name: Upload Trivy JSON results
      uses: actions/upload-artifact@v4
      with:
        name: trivy-release-results
        path: trivy-release-results.json

  deploy-release:
    name: Deploy Release
    runs-on: ubuntu-latest
    needs: [build-release, security-scan-release]
    if: always() && needs.build-release.result == 'success' && needs.security-scan-release.result == 'success'
    environment: production
    
    steps:
    - name: Gate release secrets
      id: check-release-secrets
      run: |
        missing=""
        if [[ -z "${{ secrets.PRODUCTION_HOST }}" ]]; then
          missing="${missing} PRODUCTION_HOST"
        fi
        if [[ -z "${{ secrets.PRODUCTION_USERNAME }}" ]]; then
          missing="${missing} PRODUCTION_USERNAME"
        fi
        if [[ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ]]; then
          missing="${missing} PRODUCTION_SSH_KEY"
        fi
        if [[ -n "$missing" ]]; then
          echo "Skipping deploy because secrets missing:$missing"
          echo "ready=false" >> "$GITHUB_OUTPUT"
        else
          echo "ready=true" >> "$GITHUB_OUTPUT"
        fi

    - name: Checkout code
      if: ${{ steps.check-cleanup-secrets.outputs.ready == 'true' }}
      uses: actions/checkout@v4

    - name: Deploy to production server
      if: ${{ steps.check-release-secrets.outputs.ready == 'true' }}
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PRODUCTION_HOST }}
        username: ${{ secrets.PRODUCTION_USERNAME }}
        key: ${{ secrets.PRODUCTION_SSH_KEY }}
        script: |
          cd /opt/zenamanage
          git pull origin main
          docker-compose -f docker-compose.prod.yml pull
          docker-compose -f docker-compose.prod.yml up -d
          docker-compose -f docker-compose.prod.yml exec app php artisan migrate --force
          docker-compose -f docker-compose.prod.yml exec app php artisan config:cache
          docker-compose -f docker-compose.prod.yml exec app php artisan route:cache
          docker-compose -f docker-compose.prod.yml exec app php artisan view:cache

    - name: Run health check
      if: ${{ steps.check-release-secrets.outputs.ready == 'true' }}
      run: |
        sleep 30
        curl -f https://dashboard.zenamanage.com/health || exit 1

    - name: Run smoke tests
      if: ${{ steps.check-release-secrets.outputs.ready == 'true' }}
      run: |
        # Test API endpoints
        curl -f https://api.zenamanage.com/health || exit 1
        # Test WebSocket
        curl -f https://ws.zenamanage.com/health || exit 1

    - name: Notify release deployment success
      if: ${{ steps.check-release-secrets.outputs.ready == 'true' && env.SLACK_WEBHOOK_URL != '' }}
      continue-on-error: true
      uses: 8398a7/action-slack@v3
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        status: success
        channel: '#releases'
        fields: repo,message,commit,author,action,eventName,ref,workflow
        success_message: ":white_check_mark: Succeeded GitHub Actions"
        cancelled_message: ":warning: Cancelled GitHub Actions"
        failure_message: ":no_entry: Failed GitHub Actions"

  rollback-release:
    name: Rollback Release
    runs-on: ubuntu-latest
    if: failure() && github.event_name == 'release'
    environment: production
    
    steps:
    - name: Gate rollback secrets
      id: check-rollback-secrets
      run: |
        missing=""
        if [[ -z "${{ secrets.PRODUCTION_HOST }}" ]]; then
          missing="${missing} PRODUCTION_HOST"
        fi
        if [[ -z "${{ secrets.PRODUCTION_USERNAME }}" ]]; then
          missing="${missing} PRODUCTION_USERNAME"
        fi
        if [[ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ]]; then
          missing="${missing} PRODUCTION_SSH_KEY"
        fi
        if [[ -n "$missing" ]]; then
          echo "Skipping deploy because secrets missing:$missing"
          echo "ready=false" >> "$GITHUB_OUTPUT"
        else
          echo "ready=true" >> "$GITHUB_OUTPUT"
        fi

    - name: Checkout code
      if: ${{ steps.check-rollback-secrets.outputs.ready == 'true' }}
      uses: actions/checkout@v4

    - name: Rollback to previous version
      if: ${{ steps.check-rollback-secrets.outputs.ready == 'true' }}
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PRODUCTION_HOST }}
        username: ${{ secrets.PRODUCTION_USERNAME }}
        key: ${{ secrets.PRODUCTION_SSH_KEY }}
        script: |
          cd /opt/zenamanage
          git reset --hard HEAD~1
          docker-compose -f docker-compose.prod.yml up -d
          docker-compose -f docker-compose.prod.yml exec app php artisan config:cache

    - name: Run health check after rollback
      if: ${{ steps.check-rollback-secrets.outputs.ready == 'true' }}
      run: |
        sleep 30
        curl -f https://dashboard.zenamanage.com/health || exit 1

    - name: Notify rollback
      if: ${{ steps.check-rollback-secrets.outputs.ready == 'true' && env.SLACK_WEBHOOK_URL != '' }}
      continue-on-error: true
      uses: 8398a7/action-slack@v3
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        status: failure
        channel: '#releases'
        fields: repo,message,commit,author,action,eventName,ref,workflow
        success_message: ":white_check_mark: Succeeded GitHub Actions"
        cancelled_message: ":warning: Cancelled GitHub Actions"
        failure_message: ":no_entry: Failed GitHub Actions"

  cleanup-release:
    name: Cleanup Release
    runs-on: ubuntu-latest
    needs: [deploy-release, rollback-release]
    if: always()
    
    steps:
    - name: Gate cleanup secrets
      id: check-cleanup-secrets
      run: |
        missing=""
        if [[ -z "${{ secrets.PRODUCTION_HOST }}" ]]; then
          missing="${missing} PRODUCTION_HOST"
        fi
        if [[ -z "${{ secrets.PRODUCTION_USERNAME }}" ]]; then
          missing="${missing} PRODUCTION_USERNAME"
        fi
        if [[ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ]]; then
          missing="${missing} PRODUCTION_SSH_KEY"
        fi
        if [[ -n "$missing" ]]; then
          echo "Skipping deploy because secrets missing:$missing"
          echo "ready=false" >> "$GITHUB_OUTPUT"
        else
          echo "ready=true" >> "$GITHUB_OUTPUT"
        fi

    - name: Checkout code
      uses: actions/checkout@v4

    - name: Clean up old Docker images
      if: ${{ steps.check-cleanup-secrets.outputs.ready == 'true' }}
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PRODUCTION_HOST }}
        username: ${{ secrets.PRODUCTION_USERNAME }}
        key: ${{ secrets.PRODUCTION_SSH_KEY }}
        script: |
          cd /opt/zenamanage
          # Remove old Docker images (keep last 5 versions)
          docker image prune -f
          docker system prune -f

    - name: Clean up old backups
      if: ${{ steps.check-cleanup-secrets.outputs.ready == 'true' }}
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PRODUCTION_HOST }}
        username: ${{ secrets.PRODUCTION_USERNAME }}
        key: ${{ secrets.PRODUCTION_SSH_KEY }}
        script: |
          cd /opt/zenamanage
          # Keep only last 10 backups
          ls -t backups/ | tail -n +11 | xargs -I {} rm -rf backups/{}
