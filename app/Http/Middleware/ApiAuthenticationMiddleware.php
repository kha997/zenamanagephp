<?php declare(strict_types=1);

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;
use Symfony\Component\HttpFoundation\Response;
use Src\RBAC\Services\AuthService;

/**
 * API Authentication Middleware
 * 
 * Handles authentication for API endpoints with multiple authentication methods:
 * 1. Sanctum token authentication
 * 2. Session-based authentication (for SPA)
 * 3. API key authentication (for external services)
 */
class ApiAuthenticationMiddleware
{
    private AuthService $authService;

    public function __construct(AuthService $authService)
    {
        $this->authService = $authService;
    }

    /**
     * Handle an incoming request.
     *
     * @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        try {
            // Try different authentication methods
            $user = $this->authenticateUser($request);
            
            if (!$user) {
                return $this->unauthorizedResponse('Authentication required');
            }
            
            // Set the authenticated user
            Auth::setUser($user);
            $request->setUserResolver(function () use ($user) {
                return $user;
            });
            
            // Add user context to request
            $request->attributes->set('auth_user', $user);
            $request->attributes->set('tenant_id', $user->tenant_id);
            
            // Set tenant context globally
            app()->instance('current_tenant_id', $user->tenant_id);
            
            // Log successful authentication
            Log::info('User authenticated via API', [
                'user_id' => $user->id,
                'email' => $user->email,
                'tenant_id' => $user->tenant_id,
                'method' => $this->getAuthMethod($request),
                'ip' => $request->ip(),
                'user_agent' => $request->userAgent()
            ]);
            
            return $next($request);
            
        } catch (\Exception $e) {
            Log::error('Authentication error', [
                'error' => $e->getMessage(),
                'ip' => $request->ip(),
                'user_agent' => $request->userAgent()
            ]);
            
            return $this->unauthorizedResponse('Authentication failed');
        }
    }
    
    /**
     * Authenticate user using multiple methods
     */
    private function authenticateUser(Request $request): ?\App\Models\User
    {
        // Method 0: JWT token authentication (custom AuthService)
        if ($request->bearerToken()) {
            $jwtUser = $this->authenticateViaJwt($request);
            if ($jwtUser) {
                return $jwtUser;
            }
        }

        // Method 1: Sanctum token authentication
        if ($request->bearerToken()) {
            return $this->authenticateViaSanctum($request);
        }
        
        // Method 2: Session-based authentication (for SPA)
        if ($request->hasSession() && $request->session()->has('auth')) {
            return $this->authenticateViaSession($request);
        }
        
        // Method 3: API key authentication
        if ($request->header('X-API-Key')) {
            return $this->authenticateViaApiKey($request);
        }
        
        // Method 4: Check if already authenticated via Sanctum
        if (Auth::guard('sanctum')->check()) {
            return Auth::guard('sanctum')->user();
        }
        
        return null;
    }
    
    /**
     * Authenticate via Sanctum token
     */
    private function authenticateViaSanctum(Request $request): ?\App\Models\User
    {
        $token = $request->bearerToken();
        
        if (!$token) {
            return null;
        }
        
        // Find the token in database
        $personalAccessToken = \Laravel\Sanctum\PersonalAccessToken::findToken($token);
        
        if (!$personalAccessToken) {
            return null;
        }
        
        // Check if token is expired
        if ($personalAccessToken->expires_at && $personalAccessToken->expires_at->isPast()) {
            return null;
        }
        
        // Get the user
        $user = $personalAccessToken->tokenable;
        
        if (!$user || !$user->is_active) {
            return null;
        }
        
        // Update last activity
        $personalAccessToken->forceFill([
            'last_used_at' => now(),
        ])->save();
        
        return $user;
    }

    /**
     * Authenticate via JWT token generated by AuthService.
     */
    private function authenticateViaJwt(Request $request): ?\App\Models\User
    {
        $token = $request->bearerToken();

        if (!$token || !$this->authService->isValidToken($token)) {
            return null;
        }

        return $this->authService->getCurrentUser($token);
    }
    
    /**
     * Authenticate via session (for SPA)
     */
    private function authenticateViaSession(Request $request): ?\App\Models\User
    {
        if (!$request->hasSession()) {
            return null;
        }
        
        $session = $request->session();
        $userId = $session->get('auth.user_id');
        
        if (!$userId) {
            return null;
        }
        
        $user = \App\Models\User::find($userId);
        
        if (!$user || !$user->is_active) {
            return null;
        }
        
        // Update last activity
        $user->update(['last_activity_at' => now()]);
        
        return $user;
    }
    
    /**
     * Authenticate via API key
     */
    private function authenticateViaApiKey(Request $request): ?\App\Models\User
    {
        $apiKey = $request->header('X-API-Key');
        
        if (!$apiKey) {
            return null;
        }
        
        // Find user by API key (you might want to create a separate API keys table)
        $user = \App\Models\User::where('api_key', $apiKey)
            ->where('is_active', true)
            ->first();
        
        if (!$user) {
            return null;
        }
        
        // Update last activity
        $user->update(['last_activity_at' => now()]);
        
        return $user;
    }
    
    /**
     * Get authentication method used
     */
    private function getAuthMethod(Request $request): string
    {
        if ($request->bearerToken()) {
            return 'sanctum_token';
        }
        
        if ($request->hasSession() && $request->session()->has('auth')) {
            return 'session';
        }
        
        if ($request->header('X-API-Key')) {
            return 'api_key';
        }
        
        return 'unknown';
    }
    
    /**
     * Return unauthorized response
     */
    private function unauthorizedResponse(string $message): Response
    {
        return response()->json([
            'success' => false,
            'error' => 'Unauthorized',
            'message' => $message,
            'code' => 'AUTH_REQUIRED'
        ], 401);
    }
}
