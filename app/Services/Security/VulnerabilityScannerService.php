<?php

namespace App\Services\Security;

use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\DB;

class VulnerabilityScannerService
{
    /**
     * Constructor exists for ServicesTest dependency inspection.
     */
    public function __construct()
    {
        // No dependencies required currently; keeps contract stable.
    }

    /**
     * Scan for security vulnerabilities.
     */
    public function scanVulnerabilities(): array
    {
        $scanResults = [
            'timestamp' => now()->toISOString(),
            'vulnerabilities' => [],
            'overall_risk' => 'low'
        ];

        // Scan for common vulnerabilities
        $scanResults['vulnerabilities']['sql_injection'] = $this->scanSqlInjection();
        $scanResults['vulnerabilities']['xss'] = $this->scanXss();
        $scanResults['vulnerabilities']['csrf'] = $this->scanCsrf();
        $scanResults['vulnerabilities']['file_upload'] = $this->scanFileUpload();
        $scanResults['vulnerabilities']['authentication'] = $this->scanAuthentication();
        $scanResults['vulnerabilities']['authorization'] = $this->scanAuthorization();
        $scanResults['vulnerabilities']['sensitive_data'] = $this->scanSensitiveData();
        $scanResults['vulnerabilities']['dependencies'] = $this->scanDependencies();

        // Calculate overall risk
        $scanResults['overall_risk'] = $this->calculateOverallRisk($scanResults['vulnerabilities']);

        // Generate recommendations
        $scanResults['recommendations'] = $this->generateVulnerabilityRecommendations($scanResults['vulnerabilities']);

        $this->logSecurityInfo('Vulnerability scan completed', $scanResults);

        return $scanResults;
    }

    /**
     * Alias expected by tests to keep backwards compatibility.
     */
    public function runVulnerabilityScan(): array
    {
        $scanResults = $this->scanVulnerabilities();
        $findings = [];

        foreach ($scanResults['vulnerabilities'] as $category => $details) {
            $vulnerabilities = $details['vulnerabilities'] ?? [];

            foreach ($vulnerabilities as $violation) {
                $findings[] = array_merge(['category' => $category], $violation);
            }
        }

        $scanResults['findings'] = $findings;
        $scanResults['overall_status'] = empty($findings) ? 'clean' : 'vulnerable';

        return $scanResults;
    }

    /**
     * Scan for SQL injection vulnerabilities.
     */
    protected function scanSqlInjection(): array
    {
        $vulnerabilities = [];
        $riskLevel = 'low';

        try {
            // Scan for raw SQL queries
            $files = File::allFiles(app_path());
            $sqlPatterns = [
                'DB::raw(',
                'DB::select(',
                'DB::statement(',
                'whereRaw(',
                'orderByRaw(',
                'havingRaw('
            ];

            foreach ($files as $file) {
                if ($file->getExtension() === 'php') {
                    $content = File::get($file->getPathname());
                    
                    foreach ($sqlPatterns as $pattern) {
                        if (strpos($content, $pattern) !== false) {
                            $vulnerabilities[] = [
                                'file' => $file->getRelativePathname(),
                                'pattern' => $pattern,
                                'risk' => 'medium',
                                'description' => 'Raw SQL query detected - ensure proper parameter binding'
                            ];
                            $riskLevel = 'medium';
                        }
                    }
                }
            }

        } catch (\Exception $e) {
            Log::error('Error scanning for SQL injection', ['error' => $e->getMessage()]);
        }

        return [
            'risk_level' => $riskLevel,
            'vulnerabilities' => $vulnerabilities,
            'count' => count($vulnerabilities)
        ];
    }

    /**
     * Scan for XSS vulnerabilities.
     */
    protected function scanXss(): array
    {
        $vulnerabilities = [];
        $riskLevel = 'low';

        try {
            // Scan for unescaped output
            $files = File::allFiles(resource_path('views'));
            $xssPatterns = [
                '{!!',
                'echo ',
                'print ',
                'document.write(',
                'innerHTML'
            ];

            foreach ($files as $file) {
                if ($file->getExtension() === 'php' || $file->getExtension() === 'blade.php') {
                    $content = File::get($file->getPathname());
                    
                    foreach ($xssPatterns as $pattern) {
                        if (strpos($content, $pattern) !== false) {
                            $vulnerabilities[] = [
                                'file' => $file->getRelativePathname(),
                                'pattern' => $pattern,
                                'risk' => 'high',
                                'description' => 'Unescaped output detected - ensure proper escaping'
                            ];
                            $riskLevel = 'high';
                        }
                    }
                }
            }

        } catch (\Exception $e) {
            Log::error('Error scanning for XSS', ['error' => $e->getMessage()]);
        }

        return [
            'risk_level' => $riskLevel,
            'vulnerabilities' => $vulnerabilities,
            'count' => count($vulnerabilities)
        ];
    }

    /**
     * Scan for CSRF vulnerabilities.
     */
    protected function scanCsrf(): array
    {
        $vulnerabilities = [];
        $riskLevel = 'low';

        try {
            // Check CSRF middleware
            $kernelFile = app_path('Http/Kernel.php');
            if (File::exists($kernelFile)) {
                $content = File::get($kernelFile);
                
                if (strpos($content, 'VerifyCsrfToken') === false) {
                    $vulnerabilities[] = [
                        'file' => 'Http/Kernel.php',
                        'pattern' => 'VerifyCsrfToken',
                        'risk' => 'high',
                        'description' => 'CSRF protection middleware not found'
                    ];
                    $riskLevel = 'high';
                }
            }

            // Check for forms without CSRF tokens
            $files = File::allFiles(resource_path('views'));
            foreach ($files as $file) {
                if ($file->getExtension() === 'blade.php') {
                    $content = File::get($file->getPathname());
                    
                    if (strpos($content, '<form') !== false && strpos($content, '@csrf') === false) {
                        $vulnerabilities[] = [
                            'file' => $file->getRelativePathname(),
                            'pattern' => '<form',
                            'risk' => 'medium',
                            'description' => 'Form without CSRF token detected'
                        ];
                        if ($riskLevel === 'low') $riskLevel = 'medium';
                    }
                }
            }

        } catch (\Exception $e) {
            Log::error('Error scanning for CSRF', ['error' => $e->getMessage()]);
        }

        return [
            'risk_level' => $riskLevel,
            'vulnerabilities' => $vulnerabilities,
            'count' => count($vulnerabilities)
        ];
    }

    /**
     * Scan for file upload vulnerabilities.
     */
    protected function scanFileUpload(): array
    {
        $vulnerabilities = [];
        $riskLevel = 'low';

        try {
            // Scan for file upload handling
            $files = File::allFiles(app_path());
            $uploadPatterns = [
                'move_uploaded_file(',
                'file_get_contents(',
                'fopen(',
                'file_put_contents('
            ];

            foreach ($files as $file) {
                if ($file->getExtension() === 'php') {
                    $content = File::get($file->getPathname());
                    
                    foreach ($uploadPatterns as $pattern) {
                        if (strpos($content, $pattern) !== false) {
                            $vulnerabilities[] = [
                                'file' => $file->getRelativePathname(),
                                'pattern' => $pattern,
                                'risk' => 'medium',
                                'description' => 'File upload handling detected - ensure proper validation'
                            ];
                            if ($riskLevel === 'low') $riskLevel = 'medium';
                        }
                    }
                }
            }

        } catch (\Exception $e) {
            Log::error('Error scanning for file upload vulnerabilities', ['error' => $e->getMessage()]);
        }

        return [
            'risk_level' => $riskLevel,
            'vulnerabilities' => $vulnerabilities,
            'count' => count($vulnerabilities)
        ];
    }

    /**
     * Scan for authentication vulnerabilities.
     */
    protected function scanAuthentication(): array
    {
        $vulnerabilities = [];
        $riskLevel = 'low';

        try {
            // Check for weak authentication
            $authFile = app_path('Http/Controllers/Auth/LoginController.php');
            if (File::exists($authFile)) {
                $content = File::get($authFile);
                
                // Check for password hashing
                if (strpos($content, 'Hash::make') === false && strpos($content, 'bcrypt') === false) {
                    $vulnerabilities[] = [
                        'file' => 'Http/Controllers/Auth/LoginController.php',
                        'pattern' => 'password hashing',
                        'risk' => 'high',
                        'description' => 'Password hashing not detected'
                    ];
                    $riskLevel = 'high';
                }
            }

            // Check for session security
            $sessionConfig = config_path('session.php');
            if (File::exists($sessionConfig)) {
                $content = File::get($sessionConfig);
                
                if (strpos($content, "'encrypt' => false") !== false) {
                    $vulnerabilities[] = [
                        'file' => 'config/session.php',
                        'pattern' => 'encrypt',
                        'risk' => 'medium',
                        'description' => 'Session encryption disabled'
                    ];
                    if ($riskLevel === 'low') $riskLevel = 'medium';
                }
            }

        } catch (\Exception $e) {
            Log::error('Error scanning for authentication vulnerabilities', ['error' => $e->getMessage()]);
        }

        return [
            'risk_level' => $riskLevel,
            'vulnerabilities' => $vulnerabilities,
            'count' => count($vulnerabilities)
        ];
    }

    /**
     * Scan for authorization vulnerabilities.
     */
    protected function scanAuthorization(): array
    {
        $vulnerabilities = [];
        $riskLevel = 'low';

        try {
            // Check for missing authorization
            $files = File::allFiles(app_path('Http/Controllers'));
            $authPatterns = [
                'authorize(',
                'can(',
                'cannot(',
                'Gate::allows(',
                'Gate::denies('
            ];

            foreach ($files as $file) {
                if ($file->getExtension() === 'php') {
                    $content = File::get($file->getPathname());
                    
                    // Check if controller has authorization
                    $hasAuth = false;
                    foreach ($authPatterns as $pattern) {
                        if (strpos($content, $pattern) !== false) {
                            $hasAuth = true;
                            break;
                        }
                    }
                    
                    if (!$hasAuth && strpos($content, 'class') !== false) {
                        $vulnerabilities[] = [
                            'file' => $file->getRelativePathname(),
                            'pattern' => 'authorization',
                            'risk' => 'medium',
                            'description' => 'Controller without authorization checks detected'
                        ];
                        if ($riskLevel === 'low') $riskLevel = 'medium';
                    }
                }
            }

        } catch (\Exception $e) {
            Log::error('Error scanning for authorization vulnerabilities', ['error' => $e->getMessage()]);
        }

        return [
            'risk_level' => $riskLevel,
            'vulnerabilities' => $vulnerabilities,
            'count' => count($vulnerabilities)
        ];
    }

    /**
     * Scan for sensitive data exposure.
     */
    protected function scanSensitiveData(): array
    {
        $vulnerabilities = [];
        $riskLevel = 'low';

        try {
            // Check for sensitive data in logs
            $logFiles = File::files(storage_path('logs'));
            $sensitivePatterns = [
                'password',
                'token',
                'secret',
                'key',
                'credit_card',
                'ssn'
            ];

            foreach ($logFiles as $logFile) {
                $content = File::get($logFile->getPathname());
                
                foreach ($sensitivePatterns as $pattern) {
                    if (strpos($content, $pattern) !== false) {
                        $vulnerabilities[] = [
                            'file' => $logFile->getRelativePathname(),
                            'pattern' => $pattern,
                            'risk' => 'high',
                            'description' => 'Sensitive data detected in logs'
                        ];
                        $riskLevel = 'high';
                    }
                }
            }

            // Check for sensitive data in config
            $configFiles = File::files(config_path());
            foreach ($configFiles as $configFile) {
                $content = File::get($configFile->getPathname());
                
                if (strpos($content, 'password') !== false || strpos($content, 'secret') !== false) {
                    $vulnerabilities[] = [
                        'file' => $configFile->getRelativePathname(),
                        'pattern' => 'sensitive config',
                        'risk' => 'medium',
                        'description' => 'Sensitive data in configuration file'
                    ];
                    if ($riskLevel === 'low') $riskLevel = 'medium';
                }
            }

        } catch (\Exception $e) {
            Log::error('Error scanning for sensitive data', ['error' => $e->getMessage()]);
        }

        return [
            'risk_level' => $riskLevel,
            'vulnerabilities' => $vulnerabilities,
            'count' => count($vulnerabilities)
        ];
    }

    /**
     * Scan for dependency vulnerabilities.
     */
    protected function scanDependencies(): array
    {
        $vulnerabilities = [];
        $riskLevel = 'low';

        try {
            // Check composer.json for known vulnerable packages
            $composerFile = base_path('composer.json');
            if (File::exists($composerFile)) {
                $content = File::get($composerFile);
                $composerData = json_decode($content, true);
                
                if (isset($composerData['require'])) {
                    foreach ($composerData['require'] as $package => $version) {
                        // Check for known vulnerable packages (simplified)
                        $vulnerablePackages = [
                            'laravel/framework' => '5.8.0',
                            'symfony/http-foundation' => '4.4.0'
                        ];
                        
                        if (isset($vulnerablePackages[$package])) {
                            $vulnerabilities[] = [
                                'file' => 'composer.json',
                                'pattern' => $package,
                                'risk' => 'medium',
                                'description' => "Potentially vulnerable package: {$package}"
                            ];
                            if ($riskLevel === 'low') $riskLevel = 'medium';
                        }
                    }
                }
            }

        } catch (\Exception $e) {
            Log::error('Error scanning for dependency vulnerabilities', ['error' => $e->getMessage()]);
        }

        return [
            'risk_level' => $riskLevel,
            'vulnerabilities' => $vulnerabilities,
            'count' => count($vulnerabilities)
        ];
    }

    /**
     * Calculate overall risk level.
     */
    protected function calculateOverallRisk(array $vulnerabilities): string
    {
        $riskLevels = ['low', 'medium', 'high'];
        $maxRisk = 'low';

        foreach ($vulnerabilities as $vulnerability) {
            $risk = $vulnerability['risk_level'];
            if (array_search($risk, $riskLevels) > array_search($maxRisk, $riskLevels)) {
                $maxRisk = $risk;
            }
        }

        return $maxRisk;
    }

    /**
     * Generate vulnerability recommendations.
     */
    protected function generateVulnerabilityRecommendations(array $vulnerabilities): array
    {
        $recommendations = [];

        foreach ($vulnerabilities as $type => $vulnerability) {
            if ($vulnerability['risk_level'] === 'high') {
                $recommendations[] = [
                    'priority' => 'high',
                    'type' => $type,
                    'recommendation' => $this->getVulnerabilityRecommendation($type)
                ];
            } elseif ($vulnerability['risk_level'] === 'medium') {
                $recommendations[] = [
                    'priority' => 'medium',
                    'type' => $type,
                    'recommendation' => $this->getVulnerabilityRecommendation($type)
                ];
            }
        }

        return $recommendations;
    }

    /**
     * Get specific recommendation for vulnerability type.
     */
    protected function getVulnerabilityRecommendation(string $type): string
    {
        $recommendations = [
            'sql_injection' => 'Use parameterized queries and avoid raw SQL. Use Eloquent ORM or Query Builder.',
            'xss' => 'Escape all user input and use Blade templating engine properly.',
            'csrf' => 'Enable CSRF protection middleware and include CSRF tokens in all forms.',
            'file_upload' => 'Validate file types, sizes, and scan for malware. Store files outside web root.',
            'authentication' => 'Use strong password hashing (bcrypt), enable session encryption, and implement proper session management.',
            'authorization' => 'Implement proper authorization checks using policies and gates.',
            'sensitive_data' => 'Remove sensitive data from logs and configuration files. Use environment variables.',
            'dependencies' => 'Keep all dependencies updated and scan for known vulnerabilities.'
        ];

        return $recommendations[$type] ?? 'Review and fix this security vulnerability.';
    }

    /**
     * Generate vulnerability report.
     */
    public function generateVulnerabilityReport(): array
    {
        $scanResults = $this->scanVulnerabilities();
        
        $report = [
            'title' => 'Security Vulnerability Report',
            'generated_at' => now()->toISOString(),
            'overall_risk' => $scanResults['overall_risk'],
            'total_vulnerabilities' => array_sum(array_column($scanResults['vulnerabilities'], 'count')),
            'high_risk_count' => $this->countHighRiskVulnerabilities($scanResults['vulnerabilities']),
            'medium_risk_count' => $this->countMediumRiskVulnerabilities($scanResults['vulnerabilities']),
            'low_risk_count' => $this->countLowRiskVulnerabilities($scanResults['vulnerabilities']),
            'recommendations' => $scanResults['recommendations'],
            'details' => $scanResults
        ];

        return $report;
    }

    /**
     * Count high risk vulnerabilities.
     */
    protected function countHighRiskVulnerabilities(array $vulnerabilities): int
    {
        $count = 0;
        foreach ($vulnerabilities as $vulnerability) {
            if ($vulnerability['risk_level'] === 'high') {
                $count += $vulnerability['count'];
            }
        }
        return $count;
    }

    /**
     * Count medium risk vulnerabilities.
     */
    protected function countMediumRiskVulnerabilities(array $vulnerabilities): int
    {
        $count = 0;
        foreach ($vulnerabilities as $vulnerability) {
            if ($vulnerability['risk_level'] === 'medium') {
                $count += $vulnerability['count'];
            }
        }
        return $count;
    }

    /**
     * Count low risk vulnerabilities.
     */
    protected function countLowRiskVulnerabilities(array $vulnerabilities): int
    {
        $count = 0;
        foreach ($vulnerabilities as $vulnerability) {
            if ($vulnerability['risk_level'] === 'low') {
                $count += $vulnerability['count'];
            }
        }
        return $count;
    }

    protected function logSecurityInfo(string $message, array $context = []): void
    {
        Log::info($message, $context);

        if (!app()->runningUnitTests()) {
            Log::channel('security')->info($message, $context);
        }
    }
}
