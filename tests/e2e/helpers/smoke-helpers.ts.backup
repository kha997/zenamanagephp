/**
 * E2E Test Helpers for Smoke Tests
 * 
 * Provides common utilities for smoke testing scenarios
 */

import { Page, expect } from '@playwright/test';

export interface TestUser {
  email: string;
  password: string;
  role: string;
  tenant: string;
}

export interface TestData {
  users: {
    zena: TestUser[];
    ttf: TestUser[];
  };
  projects: {
    zena: string[];
    ttf: string[];
  };
}

/**
 * Test data for E2E smoke tests
 */
export const testData: TestData = {
  users: {
    zena: [
      { email: 'owner@zena.local', password: 'password', role: 'Owner', tenant: 'ZENA Company' },
      { email: 'admin@zena.local', password: 'password', role: 'Admin', tenant: 'ZENA Company' },
      { email: 'pm@zena.local', password: 'password', role: 'Project Manager', tenant: 'ZENA Company' },
      { email: 'dev@zena.local', password: 'password', role: 'Developer', tenant: 'ZENA Company' },
      { email: 'guest@zena.local', password: 'password', role: 'Guest', tenant: 'ZENA Company' }
    ],
    ttf: [
      { email: 'owner@ttf.local', password: 'password', role: 'Owner', tenant: 'TTF Company' },
      { email: 'admin@ttf.local', password: 'password', role: 'Admin', tenant: 'TTF Company' },
      { email: 'pm@ttf.local', password: 'password', role: 'Project Manager', tenant: 'TTF Company' },
      { email: 'dev@ttf.local', password: 'password', role: 'Developer', tenant: 'TTF Company' },
      { email: 'guest@ttf.local', password: 'password', role: 'Guest', tenant: 'TTF Company' }
    ]
  },
  projects: {
    zena: ['E2E Test Project 1', 'E2E Test Project 2'],
    ttf: []
  }
};

/**
 * Common selectors for smoke tests
 */
export const selectors = {
  // Auth selectors
  auth: {
    emailInput: 'input[name="email"], input[type="email"]',
    passwordInput: 'input[name="password"], input[type="password"]',
    loginButton: 'button[type="submit"], button:has-text("Sign In"), button:has-text("Login")',
    logoutButton: 'button:has-text("Logout"), button:has-text("Sign Out")',
    forgotPasswordLink: 'a:has-text("Forgot password"), a:has-text("Forgot Password")',
    registerLink: 'a:has-text("Sign up"), a:has-text("Register")',
    passwordToggle: 'button[aria-label*="password"], button:has-text("Show"), button:has-text("Hide")'
  },
  
  // Dashboard selectors
  dashboard: {
    title: 'h1:has-text("Dashboard"), [role="heading"]:has-text("Dashboard")',
    kpiCards: '.grid.grid-cols-2.gap-4.md\\:grid-cols-4 .card, .grid.grid-cols-2.gap-4.md\\:grid-cols-4 > div',
    quickActions: 'h2:has-text("Quick Actions"), h3:has-text("Quick Actions")',
    recentProjects: 'h2:has-text("Projects"), h3:has-text("Projects")',
    alerts: 'h2:has-text("Alerts"), h3:has-text("Alerts")'
  },
  
  // Project selectors
  projects: {
    list: '.grid.grid-cols-1.md\\:grid-cols-2.lg\\:grid-cols-3.gap-6, [role="grid"]',
    createButton: 'button:has-text("New Project"), button:has-text("Create Project")',
    projectCard: '.card, [role="gridcell"]',
    projectTitle: 'h3, h4, .text-lg',
    projectStatus: '.badge, [aria-label*="status"]'
  },
  
  // Navigation selectors
  navigation: {
    sidebar: '[data-testid="sidebar"], .sidebar, nav',
    menuToggle: 'button[aria-label*="menu"], button:has-text("Menu")',
    userMenu: '[data-testid="user-menu"], .user-menu',
    themeToggle: 'button[aria-label*="theme"], button:has-text("Theme")'
  },
  
  // Form selectors
  forms: {
    submitButton: 'button[type="submit"]',
    cancelButton: 'button:has-text("Cancel")',
    saveButton: 'button:has-text("Save")',
    deleteButton: 'button:has-text("Delete")',
    editButton: 'button:has-text("Edit")'
  },
  
  // Alert/Notification selectors
  alerts: {
    successAlert: '.alert-success, [data-testid="alert-success"]',
    errorAlert: '.alert-error, [data-testid="alert-error"]',
    warningAlert: '.alert-warning, [data-testid="alert-warning"]',
    infoAlert: '.alert-info, [data-testid="alert-info"]',
    toast: '.toast, [data-testid="toast"]'
  }
};

/**
 * Authentication helpers
 */
export class AuthHelper {
  constructor(private page: Page) {}

  /**
   * Login with credentials (or navigate directly if no login required)
   */
  async login(email: string, password: string): Promise<void> {
    // For now, skip login and go directly to dashboard
    // This is because the app might not have a separate login page
    await this.page.goto('/app/dashboard');
    await this.page.waitForLoadState('networkidle');
  }

  /**
   * Logout from the application
   */
  async logout(): Promise<void> {
    // Look for user menu or logout button
    const userMenu = this.page.locator(selectors.navigation.userMenu);
    if (await userMenu.isVisible()) {
      await userMenu.click();
      await this.page.click(selectors.auth.logoutButton);
    } else {
      // Direct logout button
      await this.page.click(selectors.auth.logoutButton);
    }
    
    // Wait for redirect to login
    await this.page.waitForURL(/\/login/, { timeout: 10000 });
  }

  /**
   * Check if user is logged in
   */
  async isLoggedIn(): Promise<boolean> {
    try {
      await this.page.waitForURL(/\/app\/|\/dashboard/, { timeout: 5000 });
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Test password visibility toggle
   */
  async testPasswordToggle(): Promise<void> {
    await this.page.goto('/login');
    
    const passwordInput = this.page.locator(selectors.auth.passwordInput);
    const toggleButton = this.page.locator(selectors.auth.passwordToggle);
    
    // Initially password should be hidden
    await expect(passwordInput).toHaveAttribute('type', 'password');
    
    // Click toggle button
    await toggleButton.click();
    
    // Password should now be visible
    await expect(passwordInput).toHaveAttribute('type', 'text');
  }
}

/**
 * Dashboard helpers
 */
export class DashboardHelper {
  constructor(private page: Page) {}

  /**
   * Navigate to dashboard
   */
  async navigateToDashboard(): Promise<void> {
    await this.page.goto('/app/dashboard');
    await this.page.waitForLoadState('networkidle');
    
    // Wait for dashboard title
    const dashboardTitle = this.page.locator(selectors.dashboard.title);
    
    try {
      await dashboardTitle.waitFor({ timeout: 10000 });
    } catch {
      // Continue even if title is not found
    }
  }

  /**
   * Check if dashboard loads correctly
   */
  async verifyDashboardLoads(): Promise<void> {
    // Check dashboard title
    await expect(this.page.locator(selectors.dashboard.title)).toBeVisible();
    
    // Check for KPI cards (metrics)
    const kpiCards = this.page.locator(selectors.dashboard.kpiCards);
    const kpiCount = await kpiCards.count();
    
    if (kpiCount > 0) {
      await expect(kpiCards.first()).toBeVisible();
    }
    
    // Check for quick actions section
    const quickActions = this.page.locator(selectors.dashboard.quickActions);
    const quickActionsExists = await quickActions.isVisible();
    
    if (quickActionsExists) {
      await expect(quickActions).toBeVisible();
    }
  }

  /**
   * Test theme toggle functionality
   */
  async testThemeToggle(): Promise<void> {
    const themeToggle = this.page.locator(selectors.navigation.themeToggle);
    
    if (await themeToggle.isVisible()) {
      // Get initial theme
      const initialTheme = await this.page.evaluate(() => 
        document.documentElement.getAttribute('data-theme') || 
        document.documentElement.classList.contains('dark') ? 'dark' : 'light'
      );
      
      // Toggle theme
      await themeToggle.click();
      
      // Wait for theme change
      await this.page.waitForTimeout(500);
      
      // Verify theme changed
      const newTheme = await this.page.evaluate(() => 
        document.documentElement.getAttribute('data-theme') || 
        document.documentElement.classList.contains('dark') ? 'dark' : 'light'
      );
      
      expect(newTheme).not.toBe(initialTheme);
    }
  }
}

/**
 * Project helpers
 */
export class ProjectHelper {
  constructor(private page: Page) {}

  /**
   * Navigate to projects list
   */
  async navigateToProjects(): Promise<void> {
    await this.page.goto('/app/projects');
    await this.page.waitForLoadState('networkidle');
    
    // Wait for either projects list or page title
    const projectsList = this.page.locator(selectors.projects.list);
    const pageTitle = this.page.locator('h2:has-text("Projects"), h1:has-text("Projects")');
    
    try {
      await Promise.race([
        projectsList.waitFor({ timeout: 5000 }),
        pageTitle.waitFor({ timeout: 5000 })
      ]);
    } catch {
      // Continue even if neither is found
    }
  }

  /**
   * Check if projects list loads
   */
  async verifyProjectsListLoads(): Promise<void> {
    // Check for projects list or grid
    const projectsList = this.page.locator(selectors.projects.list);
    const listExists = await projectsList.isVisible();
    
    if (listExists) {
      await expect(projectsList).toBeVisible();
    }
    
    // Check for create button
    const createButton = this.page.locator(selectors.projects.createButton);
    const buttonExists = await createButton.isVisible();
    
    if (buttonExists) {
      await expect(createButton).toBeVisible();
    }
  }

  /**
   * Create a new project
   */
  async createProject(name: string, description: string = 'Test project'): Promise<void> {
    // Click create button
    await this.page.click(selectors.projects.createButton);
    
    // Wait for form to appear
    await this.page.waitForSelector('form', { timeout: 5000 });
    
    // Fill form
    await this.page.fill('input[name="name"], input[placeholder*="name"]', name);
    await this.page.fill('textarea[name="description"], textarea[placeholder*="description"]', description);
    
    // Submit form
    await this.page.click(selectors.forms.submitButton);
    
    // Wait for success or redirect
    await this.page.waitForTimeout(2000);
  }

  /**
   * Check if project exists in list
   */
  async verifyProjectExists(projectName: string): Promise<boolean> {
    const projectTitle = this.page.locator(selectors.projects.projectTitle).filter({ hasText: projectName });
    return await projectTitle.isVisible();
  }
}

/**
 * Navigation helpers
 */
export class NavigationHelper {
  constructor(private page: Page) {}

  /**
   * Test responsive navigation
   */
  async testResponsiveNavigation(): Promise<void> {
    // Test desktop navigation
    await this.page.setViewportSize({ width: 1200, height: 800 });
    await this.page.waitForTimeout(500);
    
    // Check if sidebar is visible
    const sidebar = this.page.locator(selectors.navigation.sidebar);
    await expect(sidebar).toBeVisible();
    
    // Test mobile navigation
    await this.page.setViewportSize({ width: 375, height: 667 });
    await this.page.waitForTimeout(500);
    
    // Check if menu toggle is visible
    const menuToggle = this.page.locator(selectors.navigation.menuToggle);
    await expect(menuToggle).toBeVisible();
    
    // Click menu toggle
    await menuToggle.click();
    
    // Check if sidebar appears
    await expect(sidebar).toBeVisible();
  }
}

/**
 * Utility functions
 */
export class TestUtils {
  /**
   * Generate unique test data
   */
  static generateUniqueName(prefix: string = 'Test'): string {
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 1000);
    return `${prefix}_${timestamp}_${random}`;
  }

  /**
   * Wait for element to be visible with timeout
   */
  static async waitForElement(page: Page, selector: string, timeout: number = 10000): Promise<void> {
    await page.waitForSelector(selector, { timeout });
  }

  /**
   * Take screenshot for debugging
   */
  static async takeScreenshot(page: Page, name: string): Promise<void> {
    await page.screenshot({ 
      path: `test-results/screenshots/${name}_${Date.now()}.png`,
      fullPage: true 
    });
  }

  /**
   * Check for console errors
   */
  static async checkConsoleErrors(page: Page): Promise<string[]> {
    const errors: string[] = [];
    
    page.on('console', msg => {
      if (msg.type() === 'error') {
        errors.push(msg.text());
      }
    });
    
    return errors;
  }
}

/**
 * Test data generators
 */
export class TestDataGenerator {
  /**
   * Generate project data
   */
  static generateProjectData() {
    return {
      name: TestUtils.generateUniqueName('Project'),
      description: 'Test project for smoke testing',
      code: TestUtils.generateUniqueName('PRJ'),
      status: 'planning'
    };
  }

  /**
   * Generate user data
   */
  static generateUserData() {
    return {
      name: TestUtils.generateUniqueName('User'),
      email: `${TestUtils.generateUniqueName('user').toLowerCase()}@test.local`,
      password: 'password123'
    };
  }
}
